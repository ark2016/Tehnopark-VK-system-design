## Разработка базы данных Steam Top Sellers

### Тип Базы Данных
Для раздела лидеров продаж в Steam оптимальным вариантом будет реляционная база данных. Основные причины выбора:
1. **Сложные запросы:** Реляционные базы данных поддерживают сложные запросы через SQL.
2. **Нормализация:** Возможность нормализовать данные для предотвращения дублирования и обеспечения целостности данных.
3. **Транзакции:** Поддержка ACID-транзакций для корректной обработки покупок.
4. **Агрегация:** Возможность построения сложных агрегационных запросов для формирования различных рейтингов.

### Структура Базы Данных и Схема
#### Основные Таблицы
1. **Users:** Таблица пользователей.
2. **Games:** Таблица игр.
3. **Tags:** Таблица тегов.
4. **GameTags:** Связующая таблица для связи игр и тегов.
5. **Purchases:** Покупки пользователей.
6. **Reviews:** Отзывы пользователей.
7. **TopSellers:** Таблица с данными о лидерах продаж.

#### Таблица Users
```sql
CREATE TABLE Users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    country VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Таблица Games
```sql
CREATE TABLE Games (
    game_id INT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    developer VARCHAR(100),
    publisher VARCHAR(100),
    release_date DATE,
    price DECIMAL(8, 2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### Таблица Tags
```sql
CREATE TABLE Tags (
    tag_id INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL
);
```

#### Таблица GameTags
```sql
CREATE TABLE GameTags (
    game_id INT,
    tag_id INT,
    PRIMARY KEY (game_id, tag_id),
    FOREIGN KEY (game_id) REFERENCES Games (game_id),
    FOREIGN KEY (tag_id) REFERENCES Tags (tag_id)
);
```

#### Таблица Purchases
```sql
CREATE TABLE Purchases (
    purchase_id INT PRIMARY KEY,
    user_id INT,
    game_id INT,
    purchase_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    amount DECIMAL(8, 2),
    FOREIGN KEY (user_id) REFERENCES Users (user_id),
    FOREIGN KEY (game_id) REFERENCES Games (game_id)
);
```

#### Таблица Reviews
```sql
CREATE TABLE Reviews (
    review_id INT PRIMARY KEY,
    user_id INT,
    game_id INT,
    rating INT CHECK (rating BETWEEN 0 AND 10),
    text TEXT,
    review_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES Users (user_id),
    FOREIGN KEY (game_id) REFERENCES Games (game_id)
);
```

#### Таблица TopSellers
```sql
CREATE TABLE TopSellers (
    rank INT,
    game_id INT,
    week_start DATE,
    week_end DATE,
    PRIMARY KEY (rank, week_start, week_end),
    FOREIGN KEY (game_id) REFERENCES Games (game_id)
);
```

### API Запросы
1. **SteamAPI_IShoppingCartService_GetShoppingCartContents**
   ```sql
   SELECT game_id, name, price
   FROM Games
   WHERE game_id IN (SELECT game_id FROM Purchases WHERE user_id = @user_id);
   ```

2. **SteamAPI_ISteamChartsService_GetBestOfYearPages**
   ```sql
   SELECT game_id, name, price, SUM(amount) AS total_sales
   FROM Purchases
   JOIN Games USING (game_id)
   WHERE EXTRACT(YEAR FROM purchase_date) = @year
   GROUP BY game_id, name, price
   ORDER BY total_sales DESC;
   ```

3. **SteamAPI_ISteamChartsService_GetTopReleasesPages**
   ```sql
   SELECT game_id, name, price, SUM(amount) AS total_sales
   FROM Purchases
   JOIN Games USING (game_id)
   WHERE release_date BETWEEN @start_date AND @end_date
   GROUP BY game_id, name, price
   ORDER BY total_sales DESC;
   ```

4. **SteamAPI_IStoreQueryService_Query**
   ```sql
   SELECT game_id, name, price
   FROM Games
   WHERE name LIKE CONCAT('%', @query, '%')
   OR game_id IN (
       SELECT game_id FROM GameTags
       JOIN Tags USING (tag_id)
       WHERE name LIKE CONCAT('%', @query, '%')
   )
   ORDER BY name;
   ```

5. **SteamAPI_IStoreService_GetTagList**
   ```sql
   SELECT tag_id, name
   FROM Tags
   ORDER BY name;
   ```
6. **SteamAPI_IStoreTopSellersService_GetWeeklyTopSellers**
   ```sql
   SELECT rank, game_id, name, price
   FROM TopSellers
   JOIN Games USING (game_id)
   WHERE week_start = @week_start AND week_end = @week_end
   ORDER BY rank;
   ```

7. **SteamAPI_best_games**
   ```sql
   SELECT game_id, name, price, rating_avg, review_count
   FROM (
       SELECT game_id, 
              name, 
              price, 
              AVG(rating) AS rating_avg, 
              COUNT(*) AS review_count
       FROM Reviews
       JOIN Games USING (game_id)
       GROUP BY game_id, name, price
   ) AS best_games
   ORDER BY rating_avg DESC, review_count DESC
   LIMIT @limit;
   ```

8. **SteamAPI_dynamicstore_saledata**
   ```sql
   SELECT game_id, name, price, SUM(amount) AS total_sales
   FROM Purchases
   JOIN Games USING (game_id)
   WHERE purchase_date BETWEEN @start_date AND @end_date
   GROUP BY game_id, name, price
   ORDER BY total_sales DESC;
   ```

9. **SteamAPI_dynamicstore_userdata**
   ```sql
   SELECT Users.user_id, Users.username, Purchases.game_id, Games.name
   FROM Purchases
   JOIN Users USING (user_id)
   JOIN Games USING (game_id)
   WHERE Users.user_id = @user_id;
   ```

### Расчет Размеров Данных и Узких Мест

**Предположения:**
1. **1 млн. пользователей**
2. **100 тыс. игр**
3. **500 тыс. тегов**
4. **10 млн. покупок**
5. **5 млн. отзывов**
6. **10 тыс. недельных топов**

**Размер Таблиц:**
- **Users**
    - `user_id`: 4 байта
    - `username`: 50 байт
    - `email`: 100 байт
    - `country`: 50 байт
    - `created_at`: 8 байт
    - **Итого**: 4 + 50 + 100 + 50 + 8 = 212 байт на пользователя
    - **Размер**: 1 млн. * 212 байт = **212 МБ**

- **Games**
    - `game_id`: 4 байта
    - `name`: 100 байт
    - `developer`: 100 байт
    - `publisher`: 100 байт
    - `release_date`: 4 байта
    - `price`: 8 байт
    - `created_at`: 8 байт
    - **Итого**: 4 + 100 + 100 + 100 + 4 + 8 + 8 = 324 байт на игру
    - **Размер**: 100 тыс. * 324 байт = **32.4 МБ**

- **Tags**
    - `tag_id`: 4 байта
    - `name`: 50 байт
    - **Итого**: 4 + 50 = 54 байта на тег
    - **Размер**: 500 тыс. * 54 байта = **27 МБ**

- **GameTags**
    - `game_id`: 4 байта
    - `tag_id`: 4 байта
    - **Итого**: 4 + 4 = 8 байт на запись
    - **Предположим по 5 тегов на игру:** 100 тыс. * 5 * 8 байт = **4 МБ**

- **Purchases**
    - `purchase_id`: 4 байта
    - `user_id`: 4 байта
    - `game_id`: 4 байта
    - `purchase_date`: 8 байт
    - `amount`: 8 байт
    - **Итого**: 4 + 4 + 4 + 8 + 8 = 28 байт на покупку
    - **Размер**: 10 млн. * 28 байт = **280 МБ**

- **Reviews**
    - `review_id`: 4 байта
    - `user_id`: 4 байта
    - `game_id`: 4 байта
    - `rating`: 4 байта
    - `text`: 500 байт (средний размер)
    - `review_date`: 8 байт
    - **Итого**: 4 + 4 + 4 + 4 + 500 + 8 = 524 байта на отзыв
    - **Размер**: 5 млн. * 524 байта = **2.62 ГБ
- **TopSellers**
    - `rank`: 4 байта
    - `game_id`: 4 байта
    - `week_start`: 4 байта
    - `week_end`: 4 байта
    - **Итого**: 4 + 4 + 4 + 4 = 16 байт на запись
    - **Предположим 100 топов в неделю в среднем, за 10 тыс. недель:** 100 * 10 тыс. * 16 байт = **16 МБ**

**Общая Оценка Размеров Данных**
- **Users:** 212 МБ
- **Games:** 32.4 МБ
- **Tags:** 27 МБ
- **GameTags:** 4 МБ
- **Purchases:** 280 МБ
- **Reviews:** 2.62 ГБ
- **TopSellers:** 16 МБ

**Общий размер базы данных:**  
`212 МБ + 32.4 МБ + 27 МБ + 4 МБ + 280 МБ + 2.62 ГБ + 16 МБ ≈ 3.19 ГБ`

### Потенциальные Узкие Места

1. **Сложные запросы к таблице Reviews:** Из-за большого количества отзывов (5 млн.) запросы с агрегацией могут занять значительное время. Например, получение списка лучших игр на основе рейтингов.

   **Решения:**
    - Добавить индексы по `game_id` и `rating`.
    - Создать материализованные представления для часто запрашиваемых агрегированных данных.

2. **Запросы к таблице Purchases:** С 10 млн. записей запросы, связанные с анализом покупок, могут быть медленными.

   **Решения:**
    - Индексы по `user_id`, `game_id` и `purchase_date`.
    - Создать отдельные таблицы-агрегаты для топовых игр по продажам за определенные периоды.

3. **Запросы к таблице TopSellers:** Узким местом могут быть запросы к недельным топам, если период большой и запросы требуют много данных.

   **Решения:**
    - Индексы по `week_start` и `week_end`.
    - Материализованные представления для часто используемых периодов.

### Использование Кэша

**Зачем нужен кэш?**
Основное назначение кэша - ускорить доступ к наиболее востребованным данным, особенно агрегированным. Можно использовать Redis или Memcached.

**Какие данные кэшировать?**
1. **Топ недельных продаж:** Кэшировать результаты запросов к таблице `TopSellers`.
    - **Ключ:** `top_sellers:{week_start}:{week_end}`
    - **Значение:** JSON-данные с рангом, `game_id`, названием и ценой игры.

   **Пример кэша:**
   ```json
   {
     "top_sellers:2024-05-01:2024-05-07": [
       {"rank": 1, "game_id": 101, "name": "Game A", "price": 29.99},
       {"rank": 2, "game_id": 102, "name": "Game B", "price": 19.99},
       "..."
     ]
   }
   ```

2. **Лучшие игры по годам:** Кэшировать результаты агрегационного запроса `SteamAPI_ISteamChartsService_GetBestOfYearPages`.
    - **Ключ:** `best_of_year:{year}`
    - **Значение:** JSON-данные с `game_id`, названием, ценой и продажами.

3. **Список тегов:** Кэшировать полный список тегов.
    - **Ключ:** `all_tags`
    - **Значение:** JSON-данные со списком тегов.

4. **Информация об игре:** Кэшировать информацию об отдельных играх.
    - **Ключ:** `game_info:{game_id}`
    - **Значение:** JSON-данные с информацией об игре.

**Заполнение кэша:**
1. **При запросе данных:**
    - Проверять кэш перед выполнением запроса.
    - Если данные не найдены, выполнить запрос к базе данных, затем записать результат в кэш.

2. **Обновление кэша:**
    - При обновлении базы данных (новые покупки, отзывы) обновлять соответствующие ключи в кэше.
    - Использовать механизм TTL (Time-To-Live) для автоматического удаления устаревших данных.

### Обзор Кэша и Потенциальных Узких Мест

1. **Кэширование Топов:**
    - Кэширование недельных топов продаж (`top_sellers:{week_start}:{week_end}`) может значительно снизить нагрузку на базу данных, так как эти запросы часто повторяются.
    - Потенциальное узкое место: если кэш не обновляется


2. **Кэширование Лучших Игр Года:**
    - Кэширование лучших игр за год (`best_of_year:{year}`) также может значительно снизить нагрузку на базу данных.
    - **Потенциальное узкое место:** Если запросы на лучшие игры за год происходят часто, а данные в базе меняются регулярно, кэш может устаревать.
    - **Решение:** Обновлять кэш автоматически каждую ночь (например, через cron job) или при добавлении новых отзывов.

3. **Кэширование Списка Тегов:**
    - Кэширование полного списка тегов (`all_tags`) позволит ускорить работу с тегами при поиске и фильтрации.
    - **Потенциальное узкое место:** Если кэш не обновляется после добавления новых тегов, данные могут устареть.
    - **Решение:** Обновлять кэш при добавлении новых тегов (например, через триггер или асинхронное задание).

4. **Кэширование Информации Об Игре:**
    - Кэширование информации об отдельных играх (`game_info:{game_id}`) ускорит доступ к детальной информации об игре.
    - **Потенциальное узкое место:** Если данные об игре обновляются, кэш может устареть.
    - **Решение:** Обновлять кэш при обновлении данных об игре (например, через триггер или асинхронное задание).
### Расчет Размеров Кэша

**Предположения:**
1. **Топ недельных продаж:** 10 тыс. записей по 100 игр в каждой.
2. **Лучшие игры за год:** 10 тыс. записей по 50 игр в каждой.
3. **Список тегов:** 500 тыс. тегов.
4. **Информация об игре:** 100 тыс. игр.

**Размер Топа Недельных Продаж:**
- **Оценка размера одной записи:**
    - `rank`: 4 байта
    - `game_id`: 4 байта
    - `name`: 50 байт
    - `price`: 8 байт
    - **Итого:** 4 + 4 + 50 + 8 = 66 байт

- **Размер одной недели:**
    - 100 игр * 66 байт = 6.6 КБ

- **Размер всех недель:**
    - 10 тыс. недель * 6.6 КБ = **66 МБ**

**Размер Лучших Игр Года:**
- **Оценка размера одной записи:**
    - `game_id`: 4 байта
    - `name`: 50 байт
    - `price`: 8 байт
    - `total_sales`: 8 байт
    - **Итого:** 4 + 50 + 8 + 8 = 70 байт

- **Размер одного года:**
    - 50 игр * 70 байт = 3.5 КБ

- **Размер всех годов:**
    - 10 тыс. годов * 3.5 КБ = **35 МБ**

**Размер Списка Тегов:**
- **Оценка размера одного тега:**
    - `tag_id`: 4 байта
    - `name`: 50 байт
    - **Итого:** 4 + 50 = 54 байта

- **Размер всех тегов:**
    - 500 тыс. * 54 байта = **27 МБ**

**Размер Информации Об Игре:**
- **Оценка размера одной записи:**
    - `game_id`: 4 байта
    - `name`: 50 байт
    - `developer`: 100 байт
    - `publisher`: 100 байт
    - `release_date`: 10 байт
    - `price`: 8 байт
    - **Итого:** 4 + 50 + 100 + 100 + 10 + 8 = 272 байта

- **Размер всех игр:**
    - 100 тыс. * 272 байта = **27.2 МБ**


### Общий Размер Кэша

1. **Топ недельных продаж:** 66 МБ
2. **Лучшие игры за год:** 35 МБ
3. **Список тегов:** 27 МБ
4. **Информация об игре:** 27.2 МБ

**Общий размер кэша:**  
66 МБ + 35 МБ + 27 МБ + 27.2 МБ = **155.2 МБ**

### Введение Кэша в Реальную Систему

1. **Обновление кэша:**
    - **Топ недельных продаж:** Обновляется еженедельно по расписанию, например, каждую ночь в понедельник.
    - **Лучшие игры за год:** Обновляется ежемесячно по расписанию или при добавлении новых отзывов.
    - **Список тегов:** Обновляется автоматически при добавлении новых тегов.
    - **Информация об игре:** Обновляется автоматически при изменении данных об игре.

2. **Использование кэша в API-запросах:**
    - **SteamAPI_ISteamChartsService_GetWeeklyTopSellers:**  
      Проверяет наличие данных в кэше `top_sellers:{week_start}:{week_end}` перед запросом к базе данных.

    - **SteamAPI_ISteamChartsService_GetBestOfYearPages:**  
      Проверяет наличие данных в кэше `best_of_year:{year}` перед запросом к базе данных.

    - **SteamAPI_IStoreService_GetTagList:**  
      Проверяет наличие данных в кэше `all_tags` перед запросом к базе данных.

    - **SteamAPI_IStoreQueryService_Query:**  
      В случае поиска по тегам, проверяет наличие данных в кэше `all_tags`.

    - **SteamAPI_IStoreService_GetGameInfo:**  
      Проверяет наличие данных в кэше `game_info:{game_id}` перед запросом к базе данных.

### Анализ Потенциальных Узких Мест

**1. Топ недельных продаж:**
- **Узкое место:** Запросы могут стать медленными, если таблица `TopSellers` содержит большой объем данных.
- **Решения:**
    - Индексировать таблицу по `week_start` и `week_end`.
    - Использовать кэширование недельных топов, как показано выше.

**2. Лучшие игры за год:**
- **Узкое место:** Запросы могут замедлиться с увеличением количества покупок.
- **Решения:**
    - Добавить индексы по `purchase_date` в таблице `Purchases`.
    - Создать материализованные представления для часто используемых агрегатов.
    - Использовать кэширование лучших игр за год.

**3. Список тегов:**
- **Узкое место:** Запросы по тегам могут замедляться при большом количестве тегов.
- **Решения:**
    - Индексировать таблицу `Tags` по `name`.
    - Использовать кэширование полного списка тегов.

**4. Информация об игре:**
- **Узкое место:** Запросы по отдельным играм могут замедляться при большом количестве игр.
- **Решения:**
    - Индексировать таблицу `Games` по `game_id` и `name`.
    - Использовать кэширование информации об игре.

### Заключение

1. **Тип Базы Данных:** Реляционная база данных выбрана из-за сложных запросов, нормализации данных и поддержки ACID-транзакций.

2. **Структура Базы Данных:**
    - Разработана структура базы данных с основными таблицами: `Users`, `Games`, `Tags`, `GameTags`, `Purchases`, `Reviews`, `TopSellers`.

3. **Размер Базы Данных и Кэша:**
    - Общий размер базы данных: **3.19 ГБ**
    - Общий размер кэша: **155.2 МБ**

4. **Узкие Места и Решения:**
    - Идентифицированы потенциальные узкие места и предложены решения для их оптимизации:
        - Индексирование таблиц
        - Материализованные представления
        - Кэширование наиболее запрашиваемых данных

**5. Отзывы об Играх:**
- **Узкое место:** Запросы к таблице `Reviews` могут быть медленными из-за большого количества отзывов (5 млн.).
- **Решения:**
    - Индексировать таблицу по `game_id` и `user_id`.
    - Добавить индексы для `rating` и `review_date`.
    - Создать материализованные представления для часто используемых агрегатов, например, средние оценки и количество отзывов на игру.
    - Использовать кэширование лучших игр на основе отзывов.

### Заключение

1. **Тип Базы Данных:** Реляционная база данных выбрана из-за сложных запросов, нормализации данных и поддержки ACID-транзакций.

2. **Структура Базы Данных:**
    - Разработана структура базы данных с основными таблицами: `Users`, `Games`, `Tags`, `GameTags`, `Purchases`, `Reviews`, `TopSellers`.

3. **Размер Базы Данных и Кэша:**
    - Общий размер базы данных: **3.19 ГБ**
    - Общий размер кэша: **155.2 МБ**

4. **Узкие Места и Решения:**
    - Идентифицированы потенциальные узкие места и предложены решения для их оптимизации:
    - Индексирование таблиц
    - Материализованные представления
    - Кэширование наиболее запрашиваемых данных